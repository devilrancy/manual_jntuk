<ion-view title="Program-9">
  <ion-content class="has-header">
  	<div class="item item-divider item-dark">
      AIM
    </div>
    <div class="card ">
    	<p>
        To implement Krushkalâ€™s algorithm to generate a min-cost spanning tree.
		  </p>
    </div>
    <div class="item item-divider item-dark">
      PROGRAM
    </div>
    <div class="card">
    	 <div class="snippet-container"><div class="sh_default snippet-wrap"><div class="snippet-menu sh_sourceCode"><a class="snippet-window sh_url" href="#">pop-up</a><a class="snippet-text sh_url" href="#">text</a></div><pre class="shi_pre sh_c snippet-formatted sh_sourceCode"><ul class="snippet-no-num"><li><span class="sh_preproc">#include</span><span class="sh_string">&lt;stdio.h&gt;</span></li><li><span class="sh_preproc">#include</span><span class="sh_string">&lt;conio.h&gt;</span></li><li><span class="sh_preproc">#include</span><span class="sh_string">&lt;stdlib.h&gt;</span></li><li><span class="sh_type">int</span> i<span class="sh_symbol">,</span>j<span class="sh_symbol">,</span>k<span class="sh_symbol">,</span>a<span class="sh_symbol">,</span>b<span class="sh_symbol">,</span>u<span class="sh_symbol">,</span>v<span class="sh_symbol">,</span>n<span class="sh_symbol">,</span>ne<span class="sh_symbol">=</span><span class="sh_number">1</span><span class="sh_symbol">;</span></li><li><span class="sh_type">int</span> min<span class="sh_symbol">,</span>mincost<span class="sh_symbol">=</span><span class="sh_number">0</span><span class="sh_symbol">,</span>cost<span class="sh_symbol">[</span><span class="sh_number">9</span><span class="sh_symbol">][</span><span class="sh_number">9</span><span class="sh_symbol">],</span>parent<span class="sh_symbol">[</span><span class="sh_number">9</span><span class="sh_symbol">];</span></li><li><span class="sh_type">int</span> <span class="sh_function">find</span><span class="sh_symbol">(</span><span class="sh_type">int</span><span class="sh_symbol">);</span>                        <span class="sh_comment">/*function to find the minimum cost*/</span></li><li><span class="sh_type">int</span> <span class="sh_function">uni</span><span class="sh_symbol">(</span><span class="sh_type">int</span><span class="sh_symbol">,</span><span class="sh_type">int</span><span class="sh_symbol">);</span>                     <span class="sh_comment">/*function to check each node is processed only once*/</span></li><li><span class="sh_type">void</span> <span class="sh_function">main</span><span class="sh_symbol">()</span></li><li><span class="sh_cbracket">{</span></li><li></li><li> <span class="sh_function">printf</span><span class="sh_symbol">(</span><span class="sh_string">"</span><span class="sh_specialchar">\n\n\t</span><span class="sh_string">Implementation of Kruskal's algorithm</span><span class="sh_specialchar">\n\n</span><span class="sh_string">"</span><span class="sh_symbol">);</span></li><li> <span class="sh_function">printf</span><span class="sh_symbol">(</span><span class="sh_string">"</span><span class="sh_specialchar">\n</span><span class="sh_string">Enter the no. of vertices</span><span class="sh_specialchar">\n</span><span class="sh_string">"</span><span class="sh_symbol">);</span></li><li> <span class="sh_function">scanf</span><span class="sh_symbol">(</span><span class="sh_string">"%d"</span><span class="sh_symbol">,&amp;</span>n<span class="sh_symbol">);</span></li><li> <span class="sh_function">printf</span><span class="sh_symbol">(</span><span class="sh_string">"</span><span class="sh_specialchar">\n</span><span class="sh_string">Enter the cost adjacency matrix</span><span class="sh_specialchar">\n</span><span class="sh_string">"</span><span class="sh_symbol">);</span></li><li> <span class="sh_keyword">for</span><span class="sh_symbol">(</span>i<span class="sh_symbol">=</span><span class="sh_number">1</span><span class="sh_symbol">;</span>i<span class="sh_symbol">&lt;=</span>n<span class="sh_symbol">;</span>i<span class="sh_symbol">++)</span></li><li> <span class="sh_cbracket">{</span></li><li>  <span class="sh_keyword">for</span><span class="sh_symbol">(</span>j<span class="sh_symbol">=</span><span class="sh_number">1</span><span class="sh_symbol">;</span>j<span class="sh_symbol">&lt;=</span>n<span class="sh_symbol">;</span>j<span class="sh_symbol">++)</span></li><li>  <span class="sh_cbracket">{</span></li><li>  </li><li> <span class="sh_function">scanf</span><span class="sh_symbol">(</span><span class="sh_string">"%d"</span><span class="sh_symbol">,&amp;</span>cost<span class="sh_symbol">[</span>i<span class="sh_symbol">][</span>j<span class="sh_symbol">]);</span></li><li>   <span class="sh_keyword">if</span><span class="sh_symbol">(</span>cost<span class="sh_symbol">[</span>i<span class="sh_symbol">][</span>j<span class="sh_symbol">]==</span><span class="sh_number">0</span><span class="sh_symbol">)</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;cost<span class="sh_symbol">[</span>i<span class="sh_symbol">][</span>j<span class="sh_symbol">]=</span><span class="sh_number">999</span><span class="sh_symbol">;</span>       <span class="sh_comment">/*setting all matrix element to 999 apart from user entered matrix element*/</span></li><li>  <span class="sh_cbracket">}</span></li><li> <span class="sh_cbracket">}</span></li><li> <span class="sh_function">printf</span><span class="sh_symbol">(</span><span class="sh_string">"</span><span class="sh_specialchar">\n</span><span class="sh_string">The edges of Minimum Cost Spanning Tree are</span><span class="sh_specialchar">\n\n</span><span class="sh_string">"</span><span class="sh_symbol">);</span></li><li> <span class="sh_keyword">while</span><span class="sh_symbol">(</span>ne<span class="sh_symbol">&lt;</span>n<span class="sh_symbol">)</span></li><li> <span class="sh_cbracket">{</span></li><li>  <span class="sh_keyword">for</span><span class="sh_symbol">(</span>i<span class="sh_symbol">=</span><span class="sh_number">1</span><span class="sh_symbol">,</span>min<span class="sh_symbol">=</span><span class="sh_number">999</span><span class="sh_symbol">;</span>i<span class="sh_symbol">&lt;=</span>n<span class="sh_symbol">;</span>i<span class="sh_symbol">++)</span></li><li>  <span class="sh_cbracket">{</span></li><li>   <span class="sh_keyword">for</span><span class="sh_symbol">(</span>j<span class="sh_symbol">=</span><span class="sh_number">1</span><span class="sh_symbol">;</span>j<span class="sh_symbol">&lt;=</span>n<span class="sh_symbol">;</span>j<span class="sh_symbol">++)</span></li><li>   <span class="sh_cbracket">{</span></li><li>    <span class="sh_keyword">if</span><span class="sh_symbol">(</span>cost<span class="sh_symbol">[</span>i<span class="sh_symbol">][</span>j<span class="sh_symbol">]&lt;</span>min<span class="sh_symbol">)</span></li><li>    <span class="sh_cbracket">{</span></li><li>     min<span class="sh_symbol">=</span>cost<span class="sh_symbol">[</span>i<span class="sh_symbol">][</span>j<span class="sh_symbol">];</span></li><li>     a<span class="sh_symbol">=</span>u<span class="sh_symbol">=</span>i<span class="sh_symbol">;</span></li><li>     b<span class="sh_symbol">=</span>v<span class="sh_symbol">=</span>j<span class="sh_symbol">;</span></li><li>    <span class="sh_cbracket">}</span></li><li>   <span class="sh_cbracket">}</span></li><li>  <span class="sh_cbracket">}</span></li><li>  u<span class="sh_symbol">=</span><span class="sh_function">find</span><span class="sh_symbol">(</span>u<span class="sh_symbol">);</span>               <span class="sh_comment">/*calling function find*/</span></li><li>  v<span class="sh_symbol">=</span><span class="sh_function">find</span><span class="sh_symbol">(</span>v<span class="sh_symbol">);</span></li><li>  <span class="sh_keyword">if</span><span class="sh_symbol">(</span><span class="sh_function">uni</span><span class="sh_symbol">(</span>u<span class="sh_symbol">,</span>v<span class="sh_symbol">))</span>            <span class="sh_comment">/*calling function uni*/</span></li><li>  <span class="sh_cbracket">{</span></li><li>   <span class="sh_function">printf</span><span class="sh_symbol">(</span><span class="sh_string">"</span><span class="sh_specialchar">\n</span><span class="sh_string">%d edge (%d,%d) =%d</span><span class="sh_specialchar">\n</span><span class="sh_string">"</span><span class="sh_symbol">,</span>ne<span class="sh_symbol">++,</span>a<span class="sh_symbol">,</span>b<span class="sh_symbol">,</span>min<span class="sh_symbol">);</span></li><li>   mincost <span class="sh_symbol">+=</span>min<span class="sh_symbol">;</span></li><li>  </li><li><span class="sh_cbracket">}</span></li><li>  cost<span class="sh_symbol">[</span>a<span class="sh_symbol">][</span>b<span class="sh_symbol">]=</span>cost<span class="sh_symbol">[</span>b<span class="sh_symbol">][</span>a<span class="sh_symbol">]=</span><span class="sh_number">999</span><span class="sh_symbol">;</span></li><li> <span class="sh_cbracket">}</span></li><li> <span class="sh_function">printf</span><span class="sh_symbol">(</span><span class="sh_string">"</span><span class="sh_specialchar">\n\t</span><span class="sh_string">Minimum cost = %d</span><span class="sh_specialchar">\n</span><span class="sh_string">"</span><span class="sh_symbol">,</span>mincost<span class="sh_symbol">);</span></li><li> <span class="sh_function">getch</span><span class="sh_symbol">();</span></li><li><span class="sh_cbracket">}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="sh_comment">/*end of main*/</span></li><li></li><li><span class="sh_type">int</span> <span class="sh_function">find</span><span class="sh_symbol">(</span><span class="sh_type">int</span> i<span class="sh_symbol">)</span></li><li><span class="sh_cbracket">{</span></li><li> <span class="sh_keyword">while</span><span class="sh_symbol">(</span>parent<span class="sh_symbol">[</span>i<span class="sh_symbol">])</span></li><li>  i<span class="sh_symbol">=</span>parent<span class="sh_symbol">[</span>i<span class="sh_symbol">];</span></li><li> <span class="sh_keyword">return</span> i<span class="sh_symbol">;</span></li><li><span class="sh_cbracket">}</span></li><li><span class="sh_type">int</span> <span class="sh_function">uni</span><span class="sh_symbol">(</span><span class="sh_type">int</span> i<span class="sh_symbol">,</span><span class="sh_type">int</span> j<span class="sh_symbol">)</span></li><li><span class="sh_cbracket">{</span></li><li> <span class="sh_keyword">if</span><span class="sh_symbol">(</span>i<span class="sh_symbol">!=</span>j<span class="sh_symbol">)</span></li><li> <span class="sh_cbracket">{</span></li><li>  parent<span class="sh_symbol">[</span>j<span class="sh_symbol">]=</span>i<span class="sh_symbol">;</span></li><li>  <span class="sh_keyword">return</span> <span class="sh_number">1</span><span class="sh_symbol">;</span></li><li> <span class="sh_cbracket">}</span></li><li> <span class="sh_keyword">return</span> <span class="sh_number">0</span><span class="sh_symbol">;</span></li><li><span class="sh_cbracket">}</span></li></ul></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;" tabindex="0" contenteditable="">#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;stdlib.h&gt;
int i,j,k,a,b,u,v,n,ne=1;
int min,mincost=0,cost[9][9],parent[9];
int find(int);                        /*function to find the minimum cost*/
int uni(int,int);                     /*function to check each node is processed only once*/
void main()
{

 printf("\n\n\tImplementation of Kruskal's algorithm\n\n");
 printf("\nEnter the no. of vertices\n");
 scanf("%d",&amp;n);
 printf("\nEnter the cost adjacency matrix\n");
 for(i=1;i&lt;=n;i++)
 {
  for(j=1;j&lt;=n;j++)
  {
  
 scanf("%d",&amp;cost[i][j]);
   if(cost[i][j]==0)
  cost[i][j]=999;       /*setting all matrix element to 999 apart from user entered matrix element*/
  }
 }
 printf("\nThe edges of Minimum Cost Spanning Tree are\n\n");
 while(ne&lt;n)
 {
  for(i=1,min=999;i&lt;=n;i++)
  {
   for(j=1;j&lt;=n;j++)
   {
    if(cost[i][j]&lt;min)
    {
     min=cost[i][j];
     a=u=i;
     b=v=j;
    }
   }
  }
  u=find(u);               /*calling function find*/
  v=find(v);
  if(uni(u,v))            /*calling function uni*/
  {
   printf("\n%d edge (%d,%d) =%d\n",ne++,a,b,min);
   mincost +=min;
  
}
  cost[a][b]=cost[b][a]=999;
 }
 printf("\n\tMinimum cost = %d\n",mincost);
 getch();
}       /*end of main*/

int find(int i)
{
 while(parent[i])
  i=parent[i];
 return i;
}
int uni(int i,int j)
{
 if(i!=j)
 {
  parent[j]=i;
  return 1;
 }
 return 0;
}
</pre></div></div>
    </div>
    <div class="item item-divider item-dark">
      OUTPUT
    </div>
    <div class="card">
    	<div class="snippet-container"><div class="sh_default snippet-wrap"><div class="snippet-menu sh_sourceCode"><a class="snippet-window sh_url" href="#">pop-up</a><a class="snippet-text sh_url" href="#">text</a></div><pre class="shi_pre sh_c snippet-formatted sh_sourceCode"><ul class="snippet-no-num"><li>Enter <span class="sh_usertype">the</span><span class="sh_normal"> </span>no<span class="sh_symbol">.</span> of vertices</li><li><span class="sh_number">5</span></li><li></li><li>Enter the cost adjacent matrix</li><li><span class="sh_number">1</span> <span class="sh_number">0</span> <span class="sh_number">2</span> <span class="sh_number">3</span> <span class="sh_number">5</span></li><li><span class="sh_number">0</span> <span class="sh_number">2</span> <span class="sh_number">5</span> <span class="sh_number">1</span> <span class="sh_number">0</span></li><li><span class="sh_number">0</span> <span class="sh_number">1</span> <span class="sh_number">0</span> <span class="sh_number">1</span> <span class="sh_number">0</span></li><li><span class="sh_number">2</span> <span class="sh_number">1</span> <span class="sh_number">3</span> <span class="sh_number">4</span> <span class="sh_number">5</span></li><li><span class="sh_number">0</span> <span class="sh_number">0</span> <span class="sh_number">0</span> <span class="sh_number">0</span> <span class="sh_number">1</span></li><li>The edges of Minimum Cost Spanning tree are</li><li><span class="sh_number">1</span> <span class="sh_function">edge</span> <span class="sh_symbol">(</span><span class="sh_number">2</span><span class="sh_symbol">,</span><span class="sh_number">4</span><span class="sh_symbol">)</span> <span class="sh_symbol">=</span> <span class="sh_number">1</span></li><li><span class="sh_number">2</span> <span class="sh_function">edge</span> <span class="sh_symbol">(</span><span class="sh_number">3</span><span class="sh_symbol">,</span><span class="sh_number">2</span><span class="sh_symbol">)</span> <span class="sh_symbol">=</span> <span class="sh_number">1</span></li><li><span class="sh_number">3</span> <span class="sh_function">edge</span> <span class="sh_symbol">(</span><span class="sh_number">1</span><span class="sh_symbol">,</span><span class="sh_number">3</span><span class="sh_symbol">)</span> <span class="sh_symbol">=</span> <span class="sh_number">2</span></li><li><span class="sh_number">4</span> <span class="sh_function">edge</span> <span class="sh_symbol">(</span><span class="sh_number">1</span><span class="sh_symbol">,</span><span class="sh_number">5</span><span class="sh_symbol">)</span> <span class="sh_symbol">=</span> <span class="sh_number">5</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;<span class="sh_usertype">Minimum</span><span class="sh_normal"> </span>cost <span class="sh_symbol">=</span> <span class="sh_number">9</span></li></ul></pre><pre class="snippet-textonly sh_sourceCode" style="display:none;" tabindex="0" contenteditable="">Enter the no. of vertices
5

Enter the cost adjacent matrix
1 0 2 3 5
0 2 5 1 0
0 1 0 1 0
2 1 3 4 5
0 0 0 0 1
The edges of Minimum Cost Spanning tree are
1 edge (2,4) = 1
2 edge (3,2) = 1
3 edge (1,3) = 2
4 edge (1,5) = 5
  Minimum cost = 9
</pre></div></div>
    </div>
  </ion-content>
</ion-view>
